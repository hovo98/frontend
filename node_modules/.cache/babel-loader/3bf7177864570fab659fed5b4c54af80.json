{"ast":null,"code":"import * as React from 'react';\nimport { useReducer, useRef, useEffect } from 'react';\nconst ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\nconst ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n\nconst useForceUpdate = () => useReducer(() => ({}))[1];\n\nconst notImplemented = name => () => {\n  const msg = `Hook \"${name}\" no possible to using inside useBetween scope.`;\n  console.error(msg);\n  throw new Error(msg);\n};\n\nconst equals = (a, b) => Object.is(a, b);\n\nconst shouldUpdate = (a, b) => !a || !b || a.length !== b.length || a.some((dep, index) => !equals(dep, b[index]));\n\nconst detectServer = () => typeof window === 'undefined';\n\nconst instances = new Map();\nlet boxes = [];\nlet pointer = 0;\nlet useEffectQueue = [];\nlet useLayoutEffectQueue = [];\n\nlet nextTick = () => {};\n\nlet isServer = detectServer();\nlet initialData = undefined;\n\nconst nextBox = () => {\n  const index = pointer++;\n  return boxes[index] = boxes[index] || {};\n};\n\nconst ownDisptacher = {\n  useState(initialState) {\n    const box = nextBox();\n    const tick = nextTick;\n\n    if (!box.initialized) {\n      box.state = typeof initialState === \"function\" ? initialState() : initialState;\n\n      box.set = fn => {\n        if (typeof fn === 'function') {\n          return box.set(fn(box.state));\n        }\n\n        if (!equals(fn, box.state)) {\n          box.state = fn;\n          tick();\n        }\n      };\n\n      box.initialized = true;\n    }\n\n    return [box.state, box.set];\n  },\n\n  useReducer(reducer, initialState, init) {\n    const box = nextBox();\n    const tick = nextTick;\n\n    if (!box.initialized) {\n      box.state = init ? init(initialState) : initialState;\n\n      box.dispatch = action => {\n        const state = reducer(box.state, action);\n\n        if (!equals(state, box.state)) {\n          box.state = state;\n          tick();\n        }\n      };\n\n      box.initialized = true;\n    }\n\n    return [box.state, box.dispatch];\n  },\n\n  useEffect(fn, deps) {\n    if (isServer) return;\n    const box = nextBox();\n\n    if (!box.initialized) {\n      box.deps = deps;\n      box.initialized = true;\n      useEffectQueue.push([box, deps, fn]);\n    } else if (shouldUpdate(box.deps, deps)) {\n      box.deps = deps;\n      useEffectQueue.push([box, deps, fn]);\n    }\n  },\n\n  useLayoutEffect(fn, deps) {\n    if (isServer) return;\n    const box = nextBox();\n\n    if (!box.initialized) {\n      box.deps = deps;\n      box.initialized = true;\n      useLayoutEffectQueue.push([box, deps, fn]);\n    } else if (shouldUpdate(box.deps, deps)) {\n      box.deps = deps;\n      useLayoutEffectQueue.push([box, deps, fn]);\n    }\n  },\n\n  useCallback(fn, deps) {\n    const box = nextBox();\n\n    if (!box.initialized) {\n      box.fn = fn;\n      box.deps = deps;\n      box.initialized = true;\n    } else if (shouldUpdate(box.deps, deps)) {\n      box.deps = deps;\n      box.fn = fn;\n    }\n\n    return box.fn;\n  },\n\n  useMemo(fn, deps) {\n    const box = nextBox();\n\n    if (!box.initialized) {\n      box.deps = deps;\n      box.state = fn();\n      box.initialized = true;\n    } else if (shouldUpdate(box.deps, deps)) {\n      box.deps = deps;\n      box.state = fn();\n    }\n\n    return box.state;\n  },\n\n  useRef(initialValue) {\n    const box = nextBox();\n\n    if (!box.initialized) {\n      box.state = {\n        current: initialValue\n      };\n      box.initialized = true;\n    }\n\n    return box.state;\n  },\n\n  useImperativeHandle(ref, fn, deps) {\n    if (isServer) return;\n    const box = nextBox();\n\n    if (!box.initialized) {\n      box.deps = deps;\n      box.initialized = true;\n      useLayoutEffectQueue.push([box, deps, () => {\n        typeof ref === 'function' ? ref(fn()) : ref.current = fn();\n      }]);\n    } else if (shouldUpdate(box.deps, deps)) {\n      box.deps = deps;\n      useLayoutEffectQueue.push([box, deps, () => {\n        typeof ref === 'function' ? ref(fn()) : ref.current = fn();\n      }]);\n    }\n  }\n\n};\n['readContext', 'useContext', 'useDebugValue', 'useResponder', 'useDeferredValue', 'useTransition'].forEach(key => ownDisptacher[key] = notImplemented(key));\n\nconst factory = (hook, options) => {\n  const scopedBoxes = [];\n  let syncs = [];\n  let state = undefined;\n  let unsubs = [];\n  let mocked = false;\n\n  if (options && options.mock) {\n    state = options.mock;\n    mocked = true;\n  }\n\n  const sync = () => {\n    syncs.slice().forEach(fn => fn());\n  };\n\n  const tick = () => {\n    if (mocked) return;\n    const originDispatcher = ReactCurrentDispatcher.current;\n    const originState = [pointer, useEffectQueue, useLayoutEffectQueue, boxes, nextTick];\n    let tickAgain = false;\n    let tickBody = true;\n    pointer = 0;\n    useEffectQueue = [];\n    useLayoutEffectQueue = [];\n    boxes = scopedBoxes;\n\n    nextTick = () => {\n      if (tickBody) {\n        tickAgain = true;\n      } else {\n        tick();\n      }\n    };\n\n    ReactCurrentDispatcher.current = ownDisptacher;\n    state = hook(initialData);\n    [useLayoutEffectQueue, useEffectQueue].forEach(queue => queue.forEach(_ref => {\n      let [box, deps, fn] = _ref;\n      box.deps = deps;\n\n      if (box.unsub) {\n        const unsub = box.unsub;\n        unsubs = unsubs.filter(fn => fn !== unsub);\n        unsub();\n      }\n\n      const unsub = fn();\n\n      if (typeof unsub === \"function\") {\n        unsubs.push(unsub);\n        box.unsub = unsub;\n      } else {\n        box.unsub = null;\n      }\n    }));\n    [pointer, useEffectQueue, useLayoutEffectQueue, boxes, nextTick] = originState;\n    ReactCurrentDispatcher.current = originDispatcher;\n    tickBody = false;\n\n    if (!tickAgain) {\n      sync();\n      return;\n    }\n\n    tick();\n  };\n\n  const sub = fn => {\n    syncs.push(fn);\n  };\n\n  const unsub = fn => {\n    syncs = syncs.filter(f => f !== fn);\n  };\n\n  const mock = obj => {\n    mocked = true;\n    state = obj;\n    sync();\n  };\n\n  const unmock = () => {\n    mocked = false;\n    tick();\n  };\n\n  return {\n    init: () => tick(),\n    get: () => state,\n    sub,\n    unsub,\n    unsubs: () => unsubs,\n    mock,\n    unmock\n  };\n};\n\nconst getInstance = hook => {\n  let inst = instances.get(hook);\n\n  if (!inst) {\n    inst = factory(hook);\n    instances.set(hook, inst);\n    inst.init();\n  }\n\n  return inst;\n};\n\nconst useBetween = hook => {\n  const forceUpdate = useForceUpdate();\n  let inst = getInstance(hook);\n  const instRef = useRef();\n\n  if (!equals(instRef.current, inst)) {\n    instRef.current = inst;\n    inst.sub(forceUpdate);\n  }\n\n  useEffect(() => () => inst.unsub(forceUpdate), [inst]);\n  return inst.get();\n};\n\nconst useInitial = (data, server) => {\n  const ref = useRef();\n\n  if (!ref.current) {\n    isServer = typeof server === 'undefined' ? detectServer() : server;\n    isServer && clear();\n    initialData = data;\n    ref.current = 1;\n  }\n};\n\nconst mock = (hook, state) => {\n  let inst = instances.get(hook);\n  if (inst) inst.mock(state);else {\n    inst = factory(hook, {\n      mock: state\n    });\n    instances.set(hook, inst);\n  }\n  return inst.unmock;\n};\n\nconst get = hook => getInstance(hook).get();\n\nconst free = function () {\n  for (var _len = arguments.length, hooks = new Array(_len), _key = 0; _key < _len; _key++) {\n    hooks[_key] = arguments[_key];\n  }\n\n  if (!hooks.length) {\n    hooks = [];\n    instances.forEach((_instance, hook) => hooks.push(hook));\n  }\n\n  let inst;\n  hooks.forEach(hook => (inst = instances.get(hook)) && inst.unsubs().slice().forEach(fn => fn()));\n  hooks.forEach(hook => instances.delete(hook));\n};\n\nconst clear = () => instances.clear();\n\nconst on = (hook, fn) => {\n  const inst = getInstance(hook);\n\n  const listener = () => fn(inst.get());\n\n  inst.sub(listener);\n  return () => inst.unsub(listener);\n};\n\nexport { clear, free, get, mock, on, useBetween, useInitial };","map":{"version":3,"sources":["/root/dex/frontend/node_modules/use-between/release/index.esm.js"],"names":["React","useReducer","useRef","useEffect","ReactSharedInternals","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","ReactCurrentDispatcher","useForceUpdate","notImplemented","name","msg","console","error","Error","equals","a","b","Object","is","shouldUpdate","length","some","dep","index","detectServer","window","instances","Map","boxes","pointer","useEffectQueue","useLayoutEffectQueue","nextTick","isServer","initialData","undefined","nextBox","ownDisptacher","useState","initialState","box","tick","initialized","state","set","fn","reducer","init","dispatch","action","deps","push","useLayoutEffect","useCallback","useMemo","initialValue","current","useImperativeHandle","ref","forEach","key","factory","hook","options","scopedBoxes","syncs","unsubs","mocked","mock","sync","slice","originDispatcher","originState","tickAgain","tickBody","queue","unsub","filter","sub","f","obj","unmock","get","getInstance","inst","useBetween","forceUpdate","instRef","useInitial","data","server","clear","free","hooks","_instance","delete","on","listener"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { useReducer, useRef, useEffect } from 'react';\n\nconst ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\r\nconst ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n\nconst useForceUpdate = () => useReducer(() => ({}))[1];\n\nconst notImplemented = (name) => () => {\r\n    const msg = `Hook \"${name}\" no possible to using inside useBetween scope.`;\r\n    console.error(msg);\r\n    throw new Error(msg);\r\n};\r\nconst equals = (a, b) => Object.is(a, b);\r\nconst shouldUpdate = (a, b) => ((!a || !b) ||\r\n    (a.length !== b.length) ||\r\n    a.some((dep, index) => !equals(dep, b[index])));\r\nconst detectServer = () => typeof window === 'undefined';\r\nconst instances = new Map();\r\nlet boxes = [];\r\nlet pointer = 0;\r\nlet useEffectQueue = [];\r\nlet useLayoutEffectQueue = [];\r\nlet nextTick = () => { };\r\nlet isServer = detectServer();\r\nlet initialData = undefined;\r\nconst nextBox = () => {\r\n    const index = pointer++;\r\n    return (boxes[index] = boxes[index] || {});\r\n};\r\nconst ownDisptacher = {\r\n    useState(initialState) {\r\n        const box = nextBox();\r\n        const tick = nextTick;\r\n        if (!box.initialized) {\r\n            box.state = typeof initialState === \"function\" ? initialState() : initialState;\r\n            box.set = (fn) => {\r\n                if (typeof fn === 'function') {\r\n                    return box.set(fn(box.state));\r\n                }\r\n                if (!equals(fn, box.state)) {\r\n                    box.state = fn;\r\n                    tick();\r\n                }\r\n            };\r\n            box.initialized = true;\r\n        }\r\n        return [box.state, box.set];\r\n    },\r\n    useReducer(reducer, initialState, init) {\r\n        const box = nextBox();\r\n        const tick = nextTick;\r\n        if (!box.initialized) {\r\n            box.state = init ? init(initialState) : initialState;\r\n            box.dispatch = (action) => {\r\n                const state = reducer(box.state, action);\r\n                if (!equals(state, box.state)) {\r\n                    box.state = state;\r\n                    tick();\r\n                }\r\n            };\r\n            box.initialized = true;\r\n        }\r\n        return [box.state, box.dispatch];\r\n    },\r\n    useEffect(fn, deps) {\r\n        if (isServer)\r\n            return;\r\n        const box = nextBox();\r\n        if (!box.initialized) {\r\n            box.deps = deps;\r\n            box.initialized = true;\r\n            useEffectQueue.push([box, deps, fn]);\r\n        }\r\n        else if (shouldUpdate(box.deps, deps)) {\r\n            box.deps = deps;\r\n            useEffectQueue.push([box, deps, fn]);\r\n        }\r\n    },\r\n    useLayoutEffect(fn, deps) {\r\n        if (isServer)\r\n            return;\r\n        const box = nextBox();\r\n        if (!box.initialized) {\r\n            box.deps = deps;\r\n            box.initialized = true;\r\n            useLayoutEffectQueue.push([box, deps, fn]);\r\n        }\r\n        else if (shouldUpdate(box.deps, deps)) {\r\n            box.deps = deps;\r\n            useLayoutEffectQueue.push([box, deps, fn]);\r\n        }\r\n    },\r\n    useCallback(fn, deps) {\r\n        const box = nextBox();\r\n        if (!box.initialized) {\r\n            box.fn = fn;\r\n            box.deps = deps;\r\n            box.initialized = true;\r\n        }\r\n        else if (shouldUpdate(box.deps, deps)) {\r\n            box.deps = deps;\r\n            box.fn = fn;\r\n        }\r\n        return box.fn;\r\n    },\r\n    useMemo(fn, deps) {\r\n        const box = nextBox();\r\n        if (!box.initialized) {\r\n            box.deps = deps;\r\n            box.state = fn();\r\n            box.initialized = true;\r\n        }\r\n        else if (shouldUpdate(box.deps, deps)) {\r\n            box.deps = deps;\r\n            box.state = fn();\r\n        }\r\n        return box.state;\r\n    },\r\n    useRef(initialValue) {\r\n        const box = nextBox();\r\n        if (!box.initialized) {\r\n            box.state = { current: initialValue };\r\n            box.initialized = true;\r\n        }\r\n        return box.state;\r\n    },\r\n    useImperativeHandle(ref, fn, deps) {\r\n        if (isServer)\r\n            return;\r\n        const box = nextBox();\r\n        if (!box.initialized) {\r\n            box.deps = deps;\r\n            box.initialized = true;\r\n            useLayoutEffectQueue.push([box, deps, () => {\r\n                    typeof ref === 'function' ? ref(fn()) : ref.current = fn();\r\n                }]);\r\n        }\r\n        else if (shouldUpdate(box.deps, deps)) {\r\n            box.deps = deps;\r\n            useLayoutEffectQueue.push([box, deps, () => {\r\n                    typeof ref === 'function' ? ref(fn()) : ref.current = fn();\r\n                }]);\r\n        }\r\n    }\r\n};\r\n[\r\n    'readContext',\r\n    'useContext',\r\n    'useDebugValue',\r\n    'useResponder',\r\n    'useDeferredValue',\r\n    'useTransition'\r\n].forEach(key => ownDisptacher[key] = notImplemented(key));\r\nconst factory = (hook, options) => {\r\n    const scopedBoxes = [];\r\n    let syncs = [];\r\n    let state = undefined;\r\n    let unsubs = [];\r\n    let mocked = false;\r\n    if (options && options.mock) {\r\n        state = options.mock;\r\n        mocked = true;\r\n    }\r\n    const sync = () => {\r\n        syncs.slice().forEach(fn => fn());\r\n    };\r\n    const tick = () => {\r\n        if (mocked)\r\n            return;\r\n        const originDispatcher = ReactCurrentDispatcher.current;\r\n        const originState = [\r\n            pointer,\r\n            useEffectQueue,\r\n            useLayoutEffectQueue,\r\n            boxes,\r\n            nextTick\r\n        ];\r\n        let tickAgain = false;\r\n        let tickBody = true;\r\n        pointer = 0;\r\n        useEffectQueue = [];\r\n        useLayoutEffectQueue = [];\r\n        boxes = scopedBoxes;\r\n        nextTick = () => {\r\n            if (tickBody) {\r\n                tickAgain = true;\r\n            }\r\n            else {\r\n                tick();\r\n            }\r\n        };\r\n        ReactCurrentDispatcher.current = ownDisptacher;\r\n        state = hook(initialData);\r\n        [useLayoutEffectQueue, useEffectQueue].forEach(queue => (queue.forEach(([box, deps, fn]) => {\r\n            box.deps = deps;\r\n            if (box.unsub) {\r\n                const unsub = box.unsub;\r\n                unsubs = unsubs.filter(fn => fn !== unsub);\r\n                unsub();\r\n            }\r\n            const unsub = fn();\r\n            if (typeof unsub === \"function\") {\r\n                unsubs.push(unsub);\r\n                box.unsub = unsub;\r\n            }\r\n            else {\r\n                box.unsub = null;\r\n            }\r\n        })));\r\n        [\r\n            pointer,\r\n            useEffectQueue,\r\n            useLayoutEffectQueue,\r\n            boxes,\r\n            nextTick\r\n        ] = originState;\r\n        ReactCurrentDispatcher.current = originDispatcher;\r\n        tickBody = false;\r\n        if (!tickAgain) {\r\n            sync();\r\n            return;\r\n        }\r\n        tick();\r\n    };\r\n    const sub = (fn) => {\r\n        syncs.push(fn);\r\n    };\r\n    const unsub = (fn) => {\r\n        syncs = syncs.filter(f => f !== fn);\r\n    };\r\n    const mock = (obj) => {\r\n        mocked = true;\r\n        state = obj;\r\n        sync();\r\n    };\r\n    const unmock = () => {\r\n        mocked = false;\r\n        tick();\r\n    };\r\n    return {\r\n        init: () => tick(),\r\n        get: () => state,\r\n        sub,\r\n        unsub,\r\n        unsubs: () => unsubs,\r\n        mock,\r\n        unmock\r\n    };\r\n};\r\nconst getInstance = (hook) => {\r\n    let inst = instances.get(hook);\r\n    if (!inst) {\r\n        inst = factory(hook);\r\n        instances.set(hook, inst);\r\n        inst.init();\r\n    }\r\n    return inst;\r\n};\r\nconst useBetween = (hook) => {\r\n    const forceUpdate = useForceUpdate();\r\n    let inst = getInstance(hook);\r\n    const instRef = useRef();\r\n    if (!equals(instRef.current, inst)) {\r\n        instRef.current = inst;\r\n        inst.sub(forceUpdate);\r\n    }\r\n    useEffect(() => () => inst.unsub(forceUpdate), [inst]);\r\n    return inst.get();\r\n};\r\nconst useInitial = (data, server) => {\r\n    const ref = useRef();\r\n    if (!ref.current) {\r\n        isServer = typeof server === 'undefined' ? detectServer() : server;\r\n        isServer && clear();\r\n        initialData = data;\r\n        ref.current = 1;\r\n    }\r\n};\r\nconst mock = (hook, state) => {\r\n    let inst = instances.get(hook);\r\n    if (inst)\r\n        inst.mock(state);\r\n    else {\r\n        inst = factory(hook, { mock: state });\r\n        instances.set(hook, inst);\r\n    }\r\n    return inst.unmock;\r\n};\r\nconst get = (hook) => getInstance(hook).get();\r\nconst free = function (...hooks) {\r\n    if (!hooks.length) {\r\n        hooks = [];\r\n        instances.forEach((_instance, hook) => hooks.push(hook));\r\n    }\r\n    let inst;\r\n    hooks.forEach((hook) => ((inst = instances.get(hook)) &&\r\n        inst.unsubs().slice().forEach((fn) => fn())));\r\n    hooks.forEach((hook) => instances.delete(hook));\r\n};\r\nconst clear = () => instances.clear();\r\nconst on = (hook, fn) => {\r\n    const inst = getInstance(hook);\r\n    const listener = () => fn(inst.get());\r\n    inst.sub(listener);\r\n    return () => inst.unsub(listener);\r\n};\n\nexport { clear, free, get, mock, on, useBetween, useInitial };\n"]},"metadata":{},"sourceType":"module"}