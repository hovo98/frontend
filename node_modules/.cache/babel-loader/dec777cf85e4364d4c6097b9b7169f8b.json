{"ast":null,"code":"import _slicedToArray from \"/root/dex/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport * as React from 'react';\nimport { useReducer, useRef, useEffect } from 'react';\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n\nvar useForceUpdate = function useForceUpdate() {\n  return useReducer(function () {\n    return {};\n  })[1];\n};\n\nvar notImplemented = function notImplemented(name) {\n  return function () {\n    var msg = \"Hook \\\"\".concat(name, \"\\\" no possible to using inside useBetween scope.\");\n    console.error(msg);\n    throw new Error(msg);\n  };\n};\n\nvar equals = function equals(a, b) {\n  return Object.is(a, b);\n};\n\nvar shouldUpdate = function shouldUpdate(a, b) {\n  return !a || !b || a.length !== b.length || a.some(function (dep, index) {\n    return !equals(dep, b[index]);\n  });\n};\n\nvar detectServer = function detectServer() {\n  return typeof window === 'undefined';\n};\n\nvar instances = new Map();\nvar boxes = [];\nvar pointer = 0;\nvar useEffectQueue = [];\nvar useLayoutEffectQueue = [];\n\nvar nextTick = function nextTick() {};\n\nvar isServer = detectServer();\nvar initialData = undefined;\n\nvar nextBox = function nextBox() {\n  var index = pointer++;\n  return boxes[index] = boxes[index] || {};\n};\n\nvar ownDisptacher = {\n  useState: function useState(initialState) {\n    var box = nextBox();\n    var tick = nextTick;\n\n    if (!box.initialized) {\n      box.state = typeof initialState === \"function\" ? initialState() : initialState;\n\n      box.set = function (fn) {\n        if (typeof fn === 'function') {\n          return box.set(fn(box.state));\n        }\n\n        if (!equals(fn, box.state)) {\n          box.state = fn;\n          tick();\n        }\n      };\n\n      box.initialized = true;\n    }\n\n    return [box.state, box.set];\n  },\n  useReducer: function useReducer(reducer, initialState, init) {\n    var box = nextBox();\n    var tick = nextTick;\n\n    if (!box.initialized) {\n      box.state = init ? init(initialState) : initialState;\n\n      box.dispatch = function (action) {\n        var state = reducer(box.state, action);\n\n        if (!equals(state, box.state)) {\n          box.state = state;\n          tick();\n        }\n      };\n\n      box.initialized = true;\n    }\n\n    return [box.state, box.dispatch];\n  },\n  useEffect: function useEffect(fn, deps) {\n    if (isServer) return;\n    var box = nextBox();\n\n    if (!box.initialized) {\n      box.deps = deps;\n      box.initialized = true;\n      useEffectQueue.push([box, deps, fn]);\n    } else if (shouldUpdate(box.deps, deps)) {\n      box.deps = deps;\n      useEffectQueue.push([box, deps, fn]);\n    }\n  },\n  useLayoutEffect: function useLayoutEffect(fn, deps) {\n    if (isServer) return;\n    var box = nextBox();\n\n    if (!box.initialized) {\n      box.deps = deps;\n      box.initialized = true;\n      useLayoutEffectQueue.push([box, deps, fn]);\n    } else if (shouldUpdate(box.deps, deps)) {\n      box.deps = deps;\n      useLayoutEffectQueue.push([box, deps, fn]);\n    }\n  },\n  useCallback: function useCallback(fn, deps) {\n    var box = nextBox();\n\n    if (!box.initialized) {\n      box.fn = fn;\n      box.deps = deps;\n      box.initialized = true;\n    } else if (shouldUpdate(box.deps, deps)) {\n      box.deps = deps;\n      box.fn = fn;\n    }\n\n    return box.fn;\n  },\n  useMemo: function useMemo(fn, deps) {\n    var box = nextBox();\n\n    if (!box.initialized) {\n      box.deps = deps;\n      box.state = fn();\n      box.initialized = true;\n    } else if (shouldUpdate(box.deps, deps)) {\n      box.deps = deps;\n      box.state = fn();\n    }\n\n    return box.state;\n  },\n  useRef: function useRef(initialValue) {\n    var box = nextBox();\n\n    if (!box.initialized) {\n      box.state = {\n        current: initialValue\n      };\n      box.initialized = true;\n    }\n\n    return box.state;\n  },\n  useImperativeHandle: function useImperativeHandle(ref, fn, deps) {\n    if (isServer) return;\n    var box = nextBox();\n\n    if (!box.initialized) {\n      box.deps = deps;\n      box.initialized = true;\n      useLayoutEffectQueue.push([box, deps, function () {\n        typeof ref === 'function' ? ref(fn()) : ref.current = fn();\n      }]);\n    } else if (shouldUpdate(box.deps, deps)) {\n      box.deps = deps;\n      useLayoutEffectQueue.push([box, deps, function () {\n        typeof ref === 'function' ? ref(fn()) : ref.current = fn();\n      }]);\n    }\n  }\n};\n['readContext', 'useContext', 'useDebugValue', 'useResponder', 'useDeferredValue', 'useTransition'].forEach(function (key) {\n  return ownDisptacher[key] = notImplemented(key);\n});\n\nvar factory = function factory(hook, options) {\n  var scopedBoxes = [];\n  var syncs = [];\n  var state = undefined;\n  var _unsubs = [];\n  var mocked = false;\n\n  if (options && options.mock) {\n    state = options.mock;\n    mocked = true;\n  }\n\n  var sync = function sync() {\n    syncs.slice().forEach(function (fn) {\n      return fn();\n    });\n  };\n\n  var tick = function tick() {\n    if (mocked) return;\n    var originDispatcher = ReactCurrentDispatcher.current;\n    var originState = [pointer, useEffectQueue, useLayoutEffectQueue, boxes, nextTick];\n    var tickAgain = false;\n    var tickBody = true;\n    pointer = 0;\n    useEffectQueue = [];\n    useLayoutEffectQueue = [];\n    boxes = scopedBoxes;\n\n    nextTick = function nextTick() {\n      if (tickBody) {\n        tickAgain = true;\n      } else {\n        tick();\n      }\n    };\n\n    ReactCurrentDispatcher.current = ownDisptacher;\n    state = hook(initialData);\n    [useLayoutEffectQueue, useEffectQueue].forEach(function (queue) {\n      return queue.forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 3),\n            box = _ref2[0],\n            deps = _ref2[1],\n            fn = _ref2[2];\n\n        box.deps = deps;\n\n        if (box.unsub) {\n          var _unsub = box.unsub;\n          _unsubs = _unsubs.filter(function (fn) {\n            return fn !== _unsub;\n          });\n\n          _unsub();\n        }\n\n        var unsub = fn();\n\n        if (typeof unsub === \"function\") {\n          _unsubs.push(unsub);\n\n          box.unsub = unsub;\n        } else {\n          box.unsub = null;\n        }\n      });\n    });\n    pointer = originState[0];\n    useEffectQueue = originState[1];\n    useLayoutEffectQueue = originState[2];\n    boxes = originState[3];\n    nextTick = originState[4];\n    ReactCurrentDispatcher.current = originDispatcher;\n    tickBody = false;\n\n    if (!tickAgain) {\n      sync();\n      return;\n    }\n\n    tick();\n  };\n\n  var sub = function sub(fn) {\n    syncs.push(fn);\n  };\n\n  var unsub = function unsub(fn) {\n    syncs = syncs.filter(function (f) {\n      return f !== fn;\n    });\n  };\n\n  var mock = function mock(obj) {\n    mocked = true;\n    state = obj;\n    sync();\n  };\n\n  var unmock = function unmock() {\n    mocked = false;\n    tick();\n  };\n\n  return {\n    init: function init() {\n      return tick();\n    },\n    get: function get() {\n      return state;\n    },\n    sub: sub,\n    unsub: unsub,\n    unsubs: function unsubs() {\n      return _unsubs;\n    },\n    mock: mock,\n    unmock: unmock\n  };\n};\n\nvar getInstance = function getInstance(hook) {\n  var inst = instances.get(hook);\n\n  if (!inst) {\n    inst = factory(hook);\n    instances.set(hook, inst);\n    inst.init();\n  }\n\n  return inst;\n};\n\nvar useBetween = function useBetween(hook) {\n  var forceUpdate = useForceUpdate();\n  var inst = getInstance(hook);\n  var instRef = useRef();\n\n  if (!equals(instRef.current, inst)) {\n    instRef.current = inst;\n    inst.sub(forceUpdate);\n  }\n\n  useEffect(function () {\n    return function () {\n      return inst.unsub(forceUpdate);\n    };\n  }, [inst]);\n  return inst.get();\n};\n\nvar useInitial = function useInitial(data, server) {\n  var ref = useRef();\n\n  if (!ref.current) {\n    isServer = typeof server === 'undefined' ? detectServer() : server;\n    isServer && clear();\n    initialData = data;\n    ref.current = 1;\n  }\n};\n\nvar mock = function mock(hook, state) {\n  var inst = instances.get(hook);\n  if (inst) inst.mock(state);else {\n    inst = factory(hook, {\n      mock: state\n    });\n    instances.set(hook, inst);\n  }\n  return inst.unmock;\n};\n\nvar get = function get(hook) {\n  return getInstance(hook).get();\n};\n\nvar free = function free() {\n  for (var _len = arguments.length, hooks = new Array(_len), _key = 0; _key < _len; _key++) {\n    hooks[_key] = arguments[_key];\n  }\n\n  if (!hooks.length) {\n    hooks = [];\n    instances.forEach(function (_instance, hook) {\n      return hooks.push(hook);\n    });\n  }\n\n  var inst;\n  hooks.forEach(function (hook) {\n    return (inst = instances.get(hook)) && inst.unsubs().slice().forEach(function (fn) {\n      return fn();\n    });\n  });\n  hooks.forEach(function (hook) {\n    return instances.delete(hook);\n  });\n};\n\nvar clear = function clear() {\n  return instances.clear();\n};\n\nvar on = function on(hook, fn) {\n  var inst = getInstance(hook);\n\n  var listener = function listener() {\n    return fn(inst.get());\n  };\n\n  inst.sub(listener);\n  return function () {\n    return inst.unsub(listener);\n  };\n};\n\nexport { clear, free, get, mock, on, useBetween, useInitial };","map":{"version":3,"sources":["/root/dex/frontend/node_modules/use-between/release/index.esm.js"],"names":["React","useReducer","useRef","useEffect","ReactSharedInternals","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","ReactCurrentDispatcher","useForceUpdate","notImplemented","name","msg","console","error","Error","equals","a","b","Object","is","shouldUpdate","length","some","dep","index","detectServer","window","instances","Map","boxes","pointer","useEffectQueue","useLayoutEffectQueue","nextTick","isServer","initialData","undefined","nextBox","ownDisptacher","useState","initialState","box","tick","initialized","state","set","fn","reducer","init","dispatch","action","deps","push","useLayoutEffect","useCallback","useMemo","initialValue","current","useImperativeHandle","ref","forEach","key","factory","hook","options","scopedBoxes","syncs","unsubs","mocked","mock","sync","slice","originDispatcher","originState","tickAgain","tickBody","queue","unsub","filter","sub","f","obj","unmock","get","getInstance","inst","useBetween","forceUpdate","instRef","useInitial","data","server","clear","free","hooks","_instance","delete","on","listener"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { useReducer, useRef, useEffect } from 'react';\n\nconst ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\r\nconst ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n\nconst useForceUpdate = () => useReducer(() => ({}))[1];\n\nconst notImplemented = (name) => () => {\r\n    const msg = `Hook \"${name}\" no possible to using inside useBetween scope.`;\r\n    console.error(msg);\r\n    throw new Error(msg);\r\n};\r\nconst equals = (a, b) => Object.is(a, b);\r\nconst shouldUpdate = (a, b) => ((!a || !b) ||\r\n    (a.length !== b.length) ||\r\n    a.some((dep, index) => !equals(dep, b[index])));\r\nconst detectServer = () => typeof window === 'undefined';\r\nconst instances = new Map();\r\nlet boxes = [];\r\nlet pointer = 0;\r\nlet useEffectQueue = [];\r\nlet useLayoutEffectQueue = [];\r\nlet nextTick = () => { };\r\nlet isServer = detectServer();\r\nlet initialData = undefined;\r\nconst nextBox = () => {\r\n    const index = pointer++;\r\n    return (boxes[index] = boxes[index] || {});\r\n};\r\nconst ownDisptacher = {\r\n    useState(initialState) {\r\n        const box = nextBox();\r\n        const tick = nextTick;\r\n        if (!box.initialized) {\r\n            box.state = typeof initialState === \"function\" ? initialState() : initialState;\r\n            box.set = (fn) => {\r\n                if (typeof fn === 'function') {\r\n                    return box.set(fn(box.state));\r\n                }\r\n                if (!equals(fn, box.state)) {\r\n                    box.state = fn;\r\n                    tick();\r\n                }\r\n            };\r\n            box.initialized = true;\r\n        }\r\n        return [box.state, box.set];\r\n    },\r\n    useReducer(reducer, initialState, init) {\r\n        const box = nextBox();\r\n        const tick = nextTick;\r\n        if (!box.initialized) {\r\n            box.state = init ? init(initialState) : initialState;\r\n            box.dispatch = (action) => {\r\n                const state = reducer(box.state, action);\r\n                if (!equals(state, box.state)) {\r\n                    box.state = state;\r\n                    tick();\r\n                }\r\n            };\r\n            box.initialized = true;\r\n        }\r\n        return [box.state, box.dispatch];\r\n    },\r\n    useEffect(fn, deps) {\r\n        if (isServer)\r\n            return;\r\n        const box = nextBox();\r\n        if (!box.initialized) {\r\n            box.deps = deps;\r\n            box.initialized = true;\r\n            useEffectQueue.push([box, deps, fn]);\r\n        }\r\n        else if (shouldUpdate(box.deps, deps)) {\r\n            box.deps = deps;\r\n            useEffectQueue.push([box, deps, fn]);\r\n        }\r\n    },\r\n    useLayoutEffect(fn, deps) {\r\n        if (isServer)\r\n            return;\r\n        const box = nextBox();\r\n        if (!box.initialized) {\r\n            box.deps = deps;\r\n            box.initialized = true;\r\n            useLayoutEffectQueue.push([box, deps, fn]);\r\n        }\r\n        else if (shouldUpdate(box.deps, deps)) {\r\n            box.deps = deps;\r\n            useLayoutEffectQueue.push([box, deps, fn]);\r\n        }\r\n    },\r\n    useCallback(fn, deps) {\r\n        const box = nextBox();\r\n        if (!box.initialized) {\r\n            box.fn = fn;\r\n            box.deps = deps;\r\n            box.initialized = true;\r\n        }\r\n        else if (shouldUpdate(box.deps, deps)) {\r\n            box.deps = deps;\r\n            box.fn = fn;\r\n        }\r\n        return box.fn;\r\n    },\r\n    useMemo(fn, deps) {\r\n        const box = nextBox();\r\n        if (!box.initialized) {\r\n            box.deps = deps;\r\n            box.state = fn();\r\n            box.initialized = true;\r\n        }\r\n        else if (shouldUpdate(box.deps, deps)) {\r\n            box.deps = deps;\r\n            box.state = fn();\r\n        }\r\n        return box.state;\r\n    },\r\n    useRef(initialValue) {\r\n        const box = nextBox();\r\n        if (!box.initialized) {\r\n            box.state = { current: initialValue };\r\n            box.initialized = true;\r\n        }\r\n        return box.state;\r\n    },\r\n    useImperativeHandle(ref, fn, deps) {\r\n        if (isServer)\r\n            return;\r\n        const box = nextBox();\r\n        if (!box.initialized) {\r\n            box.deps = deps;\r\n            box.initialized = true;\r\n            useLayoutEffectQueue.push([box, deps, () => {\r\n                    typeof ref === 'function' ? ref(fn()) : ref.current = fn();\r\n                }]);\r\n        }\r\n        else if (shouldUpdate(box.deps, deps)) {\r\n            box.deps = deps;\r\n            useLayoutEffectQueue.push([box, deps, () => {\r\n                    typeof ref === 'function' ? ref(fn()) : ref.current = fn();\r\n                }]);\r\n        }\r\n    }\r\n};\r\n[\r\n    'readContext',\r\n    'useContext',\r\n    'useDebugValue',\r\n    'useResponder',\r\n    'useDeferredValue',\r\n    'useTransition'\r\n].forEach(key => ownDisptacher[key] = notImplemented(key));\r\nconst factory = (hook, options) => {\r\n    const scopedBoxes = [];\r\n    let syncs = [];\r\n    let state = undefined;\r\n    let unsubs = [];\r\n    let mocked = false;\r\n    if (options && options.mock) {\r\n        state = options.mock;\r\n        mocked = true;\r\n    }\r\n    const sync = () => {\r\n        syncs.slice().forEach(fn => fn());\r\n    };\r\n    const tick = () => {\r\n        if (mocked)\r\n            return;\r\n        const originDispatcher = ReactCurrentDispatcher.current;\r\n        const originState = [\r\n            pointer,\r\n            useEffectQueue,\r\n            useLayoutEffectQueue,\r\n            boxes,\r\n            nextTick\r\n        ];\r\n        let tickAgain = false;\r\n        let tickBody = true;\r\n        pointer = 0;\r\n        useEffectQueue = [];\r\n        useLayoutEffectQueue = [];\r\n        boxes = scopedBoxes;\r\n        nextTick = () => {\r\n            if (tickBody) {\r\n                tickAgain = true;\r\n            }\r\n            else {\r\n                tick();\r\n            }\r\n        };\r\n        ReactCurrentDispatcher.current = ownDisptacher;\r\n        state = hook(initialData);\r\n        [useLayoutEffectQueue, useEffectQueue].forEach(queue => (queue.forEach(([box, deps, fn]) => {\r\n            box.deps = deps;\r\n            if (box.unsub) {\r\n                const unsub = box.unsub;\r\n                unsubs = unsubs.filter(fn => fn !== unsub);\r\n                unsub();\r\n            }\r\n            const unsub = fn();\r\n            if (typeof unsub === \"function\") {\r\n                unsubs.push(unsub);\r\n                box.unsub = unsub;\r\n            }\r\n            else {\r\n                box.unsub = null;\r\n            }\r\n        })));\r\n        [\r\n            pointer,\r\n            useEffectQueue,\r\n            useLayoutEffectQueue,\r\n            boxes,\r\n            nextTick\r\n        ] = originState;\r\n        ReactCurrentDispatcher.current = originDispatcher;\r\n        tickBody = false;\r\n        if (!tickAgain) {\r\n            sync();\r\n            return;\r\n        }\r\n        tick();\r\n    };\r\n    const sub = (fn) => {\r\n        syncs.push(fn);\r\n    };\r\n    const unsub = (fn) => {\r\n        syncs = syncs.filter(f => f !== fn);\r\n    };\r\n    const mock = (obj) => {\r\n        mocked = true;\r\n        state = obj;\r\n        sync();\r\n    };\r\n    const unmock = () => {\r\n        mocked = false;\r\n        tick();\r\n    };\r\n    return {\r\n        init: () => tick(),\r\n        get: () => state,\r\n        sub,\r\n        unsub,\r\n        unsubs: () => unsubs,\r\n        mock,\r\n        unmock\r\n    };\r\n};\r\nconst getInstance = (hook) => {\r\n    let inst = instances.get(hook);\r\n    if (!inst) {\r\n        inst = factory(hook);\r\n        instances.set(hook, inst);\r\n        inst.init();\r\n    }\r\n    return inst;\r\n};\r\nconst useBetween = (hook) => {\r\n    const forceUpdate = useForceUpdate();\r\n    let inst = getInstance(hook);\r\n    const instRef = useRef();\r\n    if (!equals(instRef.current, inst)) {\r\n        instRef.current = inst;\r\n        inst.sub(forceUpdate);\r\n    }\r\n    useEffect(() => () => inst.unsub(forceUpdate), [inst]);\r\n    return inst.get();\r\n};\r\nconst useInitial = (data, server) => {\r\n    const ref = useRef();\r\n    if (!ref.current) {\r\n        isServer = typeof server === 'undefined' ? detectServer() : server;\r\n        isServer && clear();\r\n        initialData = data;\r\n        ref.current = 1;\r\n    }\r\n};\r\nconst mock = (hook, state) => {\r\n    let inst = instances.get(hook);\r\n    if (inst)\r\n        inst.mock(state);\r\n    else {\r\n        inst = factory(hook, { mock: state });\r\n        instances.set(hook, inst);\r\n    }\r\n    return inst.unmock;\r\n};\r\nconst get = (hook) => getInstance(hook).get();\r\nconst free = function (...hooks) {\r\n    if (!hooks.length) {\r\n        hooks = [];\r\n        instances.forEach((_instance, hook) => hooks.push(hook));\r\n    }\r\n    let inst;\r\n    hooks.forEach((hook) => ((inst = instances.get(hook)) &&\r\n        inst.unsubs().slice().forEach((fn) => fn())));\r\n    hooks.forEach((hook) => instances.delete(hook));\r\n};\r\nconst clear = () => instances.clear();\r\nconst on = (hook, fn) => {\r\n    const inst = getInstance(hook);\r\n    const listener = () => fn(inst.get());\r\n    inst.sub(listener);\r\n    return () => inst.unsub(listener);\r\n};\n\nexport { clear, free, get, mock, on, useBetween, useInitial };\n"]},"metadata":{},"sourceType":"module"}