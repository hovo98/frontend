{"ast":null,"code":"import _asyncToGenerator from \"/root/dex/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/root/dex/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/root/dex/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _regeneratorRuntime from \"/root/dex/frontend/node_modules/@babel/runtime/regenerator/index.js\";\nimport { EventEmitter } from \"events\";\nimport fetch from \"cross-fetch\";\nimport { safeJsonParse, safeJsonStringify } from \"@walletconnect/safe-json\";\nimport { formatJsonRpcError, isHttpUrl, parseConnectionError } from \"@walletconnect/jsonrpc-utils\";\nvar DEFAULT_HTTP_HEADERS = {\n  Accept: \"application/json\",\n  \"Content-Type\": \"application/json\"\n};\nvar DEFAULT_HTTP_METHOD = \"POST\";\nvar DEFAULT_FETCH_OPTS = {\n  headers: DEFAULT_HTTP_HEADERS,\n  method: DEFAULT_HTTP_METHOD\n};\nexport var HttpConnection = /*#__PURE__*/function () {\n  function HttpConnection(url) {\n    _classCallCheck(this, HttpConnection);\n\n    this.url = url;\n    this.events = new EventEmitter();\n    this.isAvailable = false;\n    this.registering = false;\n\n    if (!isHttpUrl(url)) {\n      throw new Error(\"Provided URL is not compatible with HTTP connection: \".concat(url));\n    }\n\n    this.url = url;\n  }\n\n  _createClass(HttpConnection, [{\n    key: \"connected\",\n    get: function get() {\n      return this.isAvailable;\n    }\n  }, {\n    key: \"connecting\",\n    get: function get() {\n      return this.registering;\n    }\n  }, {\n    key: \"on\",\n    value: function on(event, listener) {\n      this.events.on(event, listener);\n    }\n  }, {\n    key: \"once\",\n    value: function once(event, listener) {\n      this.events.once(event, listener);\n    }\n  }, {\n    key: \"off\",\n    value: function off(event, listener) {\n      this.events.off(event, listener);\n    }\n  }, {\n    key: \"removeListener\",\n    value: function removeListener(event, listener) {\n      this.events.removeListener(event, listener);\n    }\n  }, {\n    key: \"open\",\n    value: function () {\n      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var url,\n            _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                url = _args.length > 0 && _args[0] !== undefined ? _args[0] : this.url;\n                _context.next = 3;\n                return this.register(url);\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function open() {\n        return _open.apply(this, arguments);\n      }\n\n      return open;\n    }()\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (this.isAvailable) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw new Error(\"Connection already closed\");\n\n              case 2:\n                this.onClose();\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function close() {\n        return _close.apply(this, arguments);\n      }\n\n      return close;\n    }()\n  }, {\n    key: \"send\",\n    value: function () {\n      var _send = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(payload, context) {\n        var body, res, data;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (this.isAvailable) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                _context3.next = 3;\n                return this.register();\n\n              case 3:\n                _context3.prev = 3;\n                body = safeJsonStringify(payload);\n                _context3.next = 7;\n                return fetch(this.url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), {\n                  body: body\n                }));\n\n              case 7:\n                res = _context3.sent;\n                _context3.next = 10;\n                return res.json();\n\n              case 10:\n                data = _context3.sent;\n                this.onPayload({\n                  data: data\n                });\n                _context3.next = 17;\n                break;\n\n              case 14:\n                _context3.prev = 14;\n                _context3.t0 = _context3[\"catch\"](3);\n                this.onError(payload.id, _context3.t0);\n\n              case 17:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[3, 14]]);\n      }));\n\n      function send(_x, _x2) {\n        return _send.apply(this, arguments);\n      }\n\n      return send;\n    }()\n  }, {\n    key: \"register\",\n    value: function () {\n      var _register = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var _this = this;\n\n        var url,\n            body,\n            error,\n            _args4 = arguments;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                url = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : this.url;\n\n                if (isHttpUrl(url)) {\n                  _context4.next = 3;\n                  break;\n                }\n\n                throw new Error(\"Provided URL is not compatible with HTTP connection: \".concat(url));\n\n              case 3:\n                if (!this.registering) {\n                  _context4.next = 5;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  _this.events.once(\"register_error\", function (error) {\n                    reject(error);\n                  });\n\n                  _this.events.once(\"open\", function () {\n                    if (typeof _this.isAvailable === \"undefined\") {\n                      return reject(new Error(\"HTTP connection is missing or invalid\"));\n                    }\n\n                    resolve();\n                  });\n                }));\n\n              case 5:\n                this.url = url;\n                this.registering = true;\n                _context4.prev = 7;\n                body = safeJsonStringify({\n                  id: 1,\n                  jsonrpc: \"2.0\",\n                  method: \"test\",\n                  params: []\n                });\n                _context4.next = 11;\n                return fetch(url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), {\n                  body: body\n                }));\n\n              case 11:\n                this.onOpen();\n                _context4.next = 20;\n                break;\n\n              case 14:\n                _context4.prev = 14;\n                _context4.t0 = _context4[\"catch\"](7);\n                error = this.parseError(_context4.t0);\n                this.events.emit(\"register_error\", error);\n                this.onClose();\n                throw error;\n\n              case 20:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[7, 14]]);\n      }));\n\n      function register() {\n        return _register.apply(this, arguments);\n      }\n\n      return register;\n    }()\n  }, {\n    key: \"onOpen\",\n    value: function onOpen() {\n      this.isAvailable = true;\n      this.registering = false;\n      this.events.emit(\"open\");\n    }\n  }, {\n    key: \"onClose\",\n    value: function onClose() {\n      this.isAvailable = false;\n      this.registering = false;\n      this.events.emit(\"close\");\n    }\n  }, {\n    key: \"onPayload\",\n    value: function onPayload(e) {\n      if (typeof e.data === \"undefined\") return;\n      var payload = typeof e.data === \"string\" ? safeJsonParse(e.data) : e.data;\n      this.events.emit(\"payload\", payload);\n    }\n  }, {\n    key: \"onError\",\n    value: function onError(id, e) {\n      var error = this.parseError(e);\n      var message = error.message || error.toString();\n      var payload = formatJsonRpcError(id, message);\n      this.events.emit(\"payload\", payload);\n    }\n  }, {\n    key: \"parseError\",\n    value: function parseError(e) {\n      var url = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.url;\n      return parseConnectionError(e, url, \"HTTP\");\n    }\n  }]);\n\n  return HttpConnection;\n}();\nexport default HttpConnection;","map":{"version":3,"sources":["../../src/http.ts"],"names":[],"mappings":";;;;AAAA,SAAS,YAAT,QAA6B,QAA7B;AACA,OAAO,KAAP,MAAkB,aAAlB;AACA,SAAS,aAAT,EAAwB,iBAAxB,QAAiD,0BAAjD;AACA,SACE,kBADF,EAIE,SAJF,EAKE,oBALF,QAMO,8BANP;AAQA,IAAM,oBAAoB,GAAG;AAC3B,EAAA,MAAM,EAAE,kBADmB;AAE3B,kBAAgB;AAFW,CAA7B;AAKA,IAAM,mBAAmB,GAAG,MAA5B;AAEA,IAAM,kBAAkB,GAAG;AACzB,EAAA,OAAO,EAAE,oBADgB;AAEzB,EAAA,MAAM,EAAE;AAFiB,CAA3B;AAKA,WAAa,cAAb;AAOE,0BAAmB,GAAnB,EAA8B;AAAA;;AAAX,SAAA,GAAA,GAAA,GAAA;AANZ,SAAA,MAAA,GAAS,IAAI,YAAJ,EAAT;AAEC,SAAA,WAAA,GAAc,KAAd;AAEA,SAAA,WAAA,GAAc,KAAd;;AAGN,QAAI,CAAC,SAAS,CAAC,GAAD,CAAd,EAAqB;AACnB,YAAM,IAAI,KAAJ,gEAAkE,GAAlE,EAAN;AACD;;AACD,SAAK,GAAL,GAAW,GAAX;AACD;;AAZH;AAAA;AAAA,SAcE,eAAa;AACX,aAAO,KAAK,WAAZ;AACD;AAhBH;AAAA;AAAA,SAkBE,eAAc;AACZ,aAAO,KAAK,WAAZ;AACD;AApBH;AAAA;AAAA,WAsBS,YAAG,KAAH,EAAkB,QAAlB,EAA+B;AACpC,WAAK,MAAL,CAAY,EAAZ,CAAe,KAAf,EAAsB,QAAtB;AACD;AAxBH;AAAA;AAAA,WA0BS,cAAK,KAAL,EAAoB,QAApB,EAAiC;AACtC,WAAK,MAAL,CAAY,IAAZ,CAAiB,KAAjB,EAAwB,QAAxB;AACD;AA5BH;AAAA;AAAA,WA8BS,aAAI,KAAJ,EAAmB,QAAnB,EAAgC;AACrC,WAAK,MAAL,CAAY,GAAZ,CAAgB,KAAhB,EAAuB,QAAvB;AACD;AAhCH;AAAA;AAAA,WAkCS,wBAAe,KAAf,EAA8B,QAA9B,EAA2C;AAChD,WAAK,MAAL,CAAY,cAAZ,CAA2B,KAA3B,EAAkC,QAAlC;AACD;AApCH;AAAA;AAAA;AAAA,2EAsCS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAW,gBAAA,GAAX,2DAAyB,KAAK,GAA9B;AAAA;AAAA,uBACC,KAAK,QAAL,CAAc,GAAd,CADD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAtCT;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,4EA0CS;AAAA;AAAA;AAAA;AAAA;AAAA,oBACA,KAAK,WADL;AAAA;AAAA;AAAA;;AAAA,sBAEG,IAAI,KAAJ,CAAU,2BAAV,CAFH;;AAAA;AAIL,qBAAK,OAAL;;AAJK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OA1CT;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2EAiDS,kBAAW,OAAX,EAAoC,OAApC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBACA,KAAK,WADL;AAAA;AAAA;AAAA;;AAAA;AAAA,uBAEG,KAAK,QAAL,EAFH;;AAAA;AAAA;AAKG,gBAAA,IALH,GAKU,iBAAiB,CAAC,OAAD,CAL3B;AAAA;AAAA,uBAMe,KAAK,CAAC,KAAK,GAAN,EAAS,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAO,kBAAP,CAAA,EAAyB;AAAE,kBAAA,IAAI,EAAJ;AAAF,iBAAzB,CAAT,CANpB;;AAAA;AAMG,gBAAA,GANH;AAAA;AAAA,uBAOgB,GAAG,CAAC,IAAJ,EAPhB;;AAAA;AAOG,gBAAA,IAPH;AAQH,qBAAK,SAAL,CAAe;AAAE,kBAAA,IAAI,EAAJ;AAAF,iBAAf;AARG;AAAA;;AAAA;AAAA;AAAA;AAUH,qBAAK,OAAL,CAAa,OAAO,CAAC,EAArB;;AAVG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAjDT;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+EAiEU;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAe,gBAAA,GAAf,8DAAqB,KAAK,GAA1B;;AAAA,oBACD,SAAS,CAAC,GAAD,CADR;AAAA;AAAA;AAAA;;AAAA,sBAEE,IAAI,KAAJ,gEAAkE,GAAlE,EAFF;;AAAA;AAAA,qBAIF,KAAK,WAJH;AAAA;AAAA;AAAA;;AAAA,kDAKG,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAoB;AACrC,kBAAA,KAAI,CAAC,MAAL,CAAY,IAAZ,CAAiB,gBAAjB,EAAmC,UAAA,KAAK,EAAG;AACzC,oBAAA,MAAM,CAAC,KAAD,CAAN;AACD,mBAFD;;AAGA,kBAAA,KAAI,CAAC,MAAL,CAAY,IAAZ,CAAiB,MAAjB,EAAyB,YAAK;AAC5B,wBAAI,OAAO,KAAI,CAAC,WAAZ,KAA4B,WAAhC,EAA6C;AAC3C,6BAAO,MAAM,CAAC,IAAI,KAAJ,CAAU,uCAAV,CAAD,CAAb;AACD;;AACD,oBAAA,OAAO;AACR,mBALD;AAMD,iBAVM,CALH;;AAAA;AAiBN,qBAAK,GAAL,GAAW,GAAX;AACA,qBAAK,WAAL,GAAmB,IAAnB;AAlBM;AAoBE,gBAAA,IApBF,GAoBS,iBAAiB,CAAC;AAAE,kBAAA,EAAE,EAAE,CAAN;AAAS,kBAAA,OAAO,EAAE,KAAlB;AAAyB,kBAAA,MAAM,EAAE,MAAjC;AAAyC,kBAAA,MAAM,EAAE;AAAjD,iBAAD,CApB1B;AAAA;AAAA,uBAqBE,KAAK,CAAC,GAAD,EAAI,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAO,kBAAP,CAAA,EAAyB;AAAE,kBAAA,IAAI,EAAJ;AAAF,iBAAzB,CAAJ,CArBP;;AAAA;AAsBJ,qBAAK,MAAL;AAtBI;AAAA;;AAAA;AAAA;AAAA;AAwBE,gBAAA,KAxBF,GAwBU,KAAK,UAAL,cAxBV;AAyBJ,qBAAK,MAAL,CAAY,IAAZ,CAAiB,gBAAjB,EAAmC,KAAnC;AACA,qBAAK,OAAL;AA1BI,sBA2BE,KA3BF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAjEV;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,WAgGU,kBAAM;AACZ,WAAK,WAAL,GAAmB,IAAnB;AACA,WAAK,WAAL,GAAmB,KAAnB;AACA,WAAK,MAAL,CAAY,IAAZ,CAAiB,MAAjB;AACD;AApGH;AAAA;AAAA,WAsGU,mBAAO;AACb,WAAK,WAAL,GAAmB,KAAnB;AACA,WAAK,WAAL,GAAmB,KAAnB;AACA,WAAK,MAAL,CAAY,IAAZ,CAAiB,OAAjB;AACD;AA1GH;AAAA;AAAA,WA4GU,mBAAU,CAAV,EAA0B;AAChC,UAAI,OAAO,CAAC,CAAC,IAAT,KAAkB,WAAtB,EAAmC;AACnC,UAAM,OAAO,GAAmB,OAAO,CAAC,CAAC,IAAT,KAAkB,QAAlB,GAA6B,aAAa,CAAC,CAAC,CAAC,IAAH,CAA1C,GAAqD,CAAC,CAAC,IAAvF;AACA,WAAK,MAAL,CAAY,IAAZ,CAAiB,SAAjB,EAA4B,OAA5B;AACD;AAhHH;AAAA;AAAA,WAkHU,iBAAQ,EAAR,EAAoB,CAApB,EAA4B;AAClC,UAAM,KAAK,GAAG,KAAK,UAAL,CAAgB,CAAhB,CAAd;AACA,UAAM,OAAO,GAAG,KAAK,CAAC,OAAN,IAAiB,KAAK,CAAC,QAAN,EAAjC;AACA,UAAM,OAAO,GAAG,kBAAkB,CAAC,EAAD,EAAK,OAAL,CAAlC;AACA,WAAK,MAAL,CAAY,IAAZ,CAAiB,SAAjB,EAA4B,OAA5B;AACD;AAvHH;AAAA;AAAA,WAyHU,oBAAW,CAAX,EAAmC;AAAA,UAAd,GAAc,uEAAR,KAAK,GAAG;AACzC,aAAO,oBAAoB,CAAC,CAAD,EAAI,GAAJ,EAAS,MAAT,CAA3B;AACD;AA3HH;;AAAA;AAAA;AA8HA,eAAe,cAAf","sourceRoot":"","sourcesContent":["import { EventEmitter } from \"events\";\nimport fetch from \"cross-fetch\";\nimport { safeJsonParse, safeJsonStringify } from \"@walletconnect/safe-json\";\nimport { formatJsonRpcError, isHttpUrl, parseConnectionError, } from \"@walletconnect/jsonrpc-utils\";\nconst DEFAULT_HTTP_HEADERS = {\n    Accept: \"application/json\",\n    \"Content-Type\": \"application/json\",\n};\nconst DEFAULT_HTTP_METHOD = \"POST\";\nconst DEFAULT_FETCH_OPTS = {\n    headers: DEFAULT_HTTP_HEADERS,\n    method: DEFAULT_HTTP_METHOD,\n};\nexport class HttpConnection {\n    constructor(url) {\n        this.url = url;\n        this.events = new EventEmitter();\n        this.isAvailable = false;\n        this.registering = false;\n        if (!isHttpUrl(url)) {\n            throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);\n        }\n        this.url = url;\n    }\n    get connected() {\n        return this.isAvailable;\n    }\n    get connecting() {\n        return this.registering;\n    }\n    on(event, listener) {\n        this.events.on(event, listener);\n    }\n    once(event, listener) {\n        this.events.once(event, listener);\n    }\n    off(event, listener) {\n        this.events.off(event, listener);\n    }\n    removeListener(event, listener) {\n        this.events.removeListener(event, listener);\n    }\n    async open(url = this.url) {\n        await this.register(url);\n    }\n    async close() {\n        if (!this.isAvailable) {\n            throw new Error(\"Connection already closed\");\n        }\n        this.onClose();\n    }\n    async send(payload, context) {\n        if (!this.isAvailable) {\n            await this.register();\n        }\n        try {\n            const body = safeJsonStringify(payload);\n            const res = await fetch(this.url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), { body }));\n            const data = await res.json();\n            this.onPayload({ data });\n        }\n        catch (e) {\n            this.onError(payload.id, e);\n        }\n    }\n    async register(url = this.url) {\n        if (!isHttpUrl(url)) {\n            throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);\n        }\n        if (this.registering) {\n            return new Promise((resolve, reject) => {\n                this.events.once(\"register_error\", error => {\n                    reject(error);\n                });\n                this.events.once(\"open\", () => {\n                    if (typeof this.isAvailable === \"undefined\") {\n                        return reject(new Error(\"HTTP connection is missing or invalid\"));\n                    }\n                    resolve();\n                });\n            });\n        }\n        this.url = url;\n        this.registering = true;\n        try {\n            const body = safeJsonStringify({ id: 1, jsonrpc: \"2.0\", method: \"test\", params: [] });\n            await fetch(url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), { body }));\n            this.onOpen();\n        }\n        catch (e) {\n            const error = this.parseError(e);\n            this.events.emit(\"register_error\", error);\n            this.onClose();\n            throw error;\n        }\n    }\n    onOpen() {\n        this.isAvailable = true;\n        this.registering = false;\n        this.events.emit(\"open\");\n    }\n    onClose() {\n        this.isAvailable = false;\n        this.registering = false;\n        this.events.emit(\"close\");\n    }\n    onPayload(e) {\n        if (typeof e.data === \"undefined\")\n            return;\n        const payload = typeof e.data === \"string\" ? safeJsonParse(e.data) : e.data;\n        this.events.emit(\"payload\", payload);\n    }\n    onError(id, e) {\n        const error = this.parseError(e);\n        const message = error.message || error.toString();\n        const payload = formatJsonRpcError(id, message);\n        this.events.emit(\"payload\", payload);\n    }\n    parseError(e, url = this.url) {\n        return parseConnectionError(e, url, \"HTTP\");\n    }\n}\nexport default HttpConnection;\n//# sourceMappingURL=http.js.map"]},"metadata":{},"sourceType":"module"}